<pre>
  OEP: 64
  Title: Governance Change Standard
  Author:
  Type: Standard
  Status: Accepted
  Created: 2018-07-03
</pre>

==Abstract==

The OEP-64 proposal is a standard interface for the '''Governance Change Standard'''.
All consensus nodes and candidate nodes can participate in the governance of ontology by creating and voting on topics.
The `GOV` node will be used instead of all consensus nodes and candidate nodes.
`Topic` is used to represent a major update of ontology, including the initiator address, topic title, topic detail, start voting time and end voting time.
The `GOV` node can create a topic. All the `GOV` nodes can approve or reject the topic. Non `GOV` nodes cannot create or participate in the topic voting.
The voting weight of the `GOV` node is expressed by the number of ont pledged by the node.
`Topic` needs to be approved by most nodes before it is updated to the Ontology main network. During the voting process, the number of votes for and against will be counted.
The number of votes in favor is greater than the number of votes in opposition and the number of votes in favor is more than 50%,
 the update of the Topic representative will be updated to the Ontology main network.


==Motivation==

'''Governance Change Standard''' interface allows the community to update the governance strategy of Ontology blockchain in order to adapt to new developments.

==Specification==

===Methods===

====listGovNodes====

<pre>
fn list_gov_nodes() -> Vec<Address> {}
</pre>

Returns the address array that contains all the Governance nodes.

====createTopic====

<pre>
fn create_topic(gov_node_address: Address,topic_title: &[u8],topic_detail: &[u8],start_time: U128,end_time: U128) -> bool {}
</pre>

Only `Gov` node can invoke this method to create a new topic.


The parameters are of the following type:

{| class = "wikitable"
! style = "text-align:center;"| Parameter
! Type
|-
| gov_node_address
| Address
|-
| topic_title
| bytearray
|-
| topic_detail
| bytearray
|-
| start_time
| UNIX timestamp
|-
| end_time
| UNIX timestamp
|}

====listTopics====

<pre>
fn list_topic_hash() -> Vec<H256> {}
</pre>

Returns all the topic hashes.

====getTopic====

<pre>
fn get_topic(hash: &H256) -> Option<Topic>{}
</pre>
Return value data type is `Option<Topic>`, `option` means this value maybe null.
`Topic` is defined as followsï¼š
```
pub struct Topic {
    pub topic_title: Vec<u8>,
    pub topic_detail: Vec<u8>,
}
```
The parameter <code>hash</code> should be a 32-byte hash that corresponds to a topic.

====cancelTopic====

<pre>
fn cancel_topic(hash: &H256) -> bool {}
</pre>
only the Topic creator has the right to invoke this method.

The parameter <code>hash</code> should be the 32-byte hash of the topic name.


====getTopicInfo====

<pre>
fn get_topic_info(hash: &H256) -> Option<TopicInfo> {}
</pre>

Return value data type is `Option<TopicInfo>`,`option` means this value maybe null.

<code>TopicInfo</code> is defined as follows:
```
pub struct TopicInfo {
    pub gov_node_addr: Address,
    pub topic_title: Vec<u8>,
    pub topic_detail: Vec<u8>,
    pub voters: Vec<VoterWeight>,
    pub start_time: u64,
    pub end_time: u64,
    pub approve: u64,
    pub reject: u64,
    pub status: u8,
    pub hash: H256,
}
```

The parameter <code>hash</code> should be the 32-byte hash of the topic hash.

Response description:

* <code>gov_node_addr</code>: Creator of the topic
* <code>topic_title</code>: Topic title
* <code>topic_detail</code>: Topic details
* <code>start_time</code>: Start time for voting on the topic
* <code>end_time</code>:End time for voting on the topic
* <code>approve amount</code>: Total number of voters that approve the topic, sum of the weights of approving voters
* <code>reject amount</code>: Total number of voters that reject the topic, sum of the weights of rejecting voters
* <code>status</code>: Status of the topic, <code>0</code> represents <code>cancelled</code>, <code>1</code> represents <code>normal</code>
* <code>hash</code>: Topic hash

====voteTopic====

<pre>
fn vote_topic(hash: &H256, voter: Address, approve_or_reject: bool) -> bool {}
</pre>

Voters can invoke this method to approve or reject a topic.

The parameter <code>hash</code> is the topic hash.
The parameter <code>voter</code> is one of the `Gov` nodes.
The parameter <code>approveOrReject</code> is a boolean value, true implies approve, false implies reject.


====getVotedInfo====

<pre>
fn get_voted_info(hash: &H256, voter: &Address) -> u8{}
</pre>

Voters can invoke this method to query own voted Info, approve or reject.

The parameter <code>hash</code> is the topic hash.
The parameter <code>voter</code> is one of the voters set by an admin.

Return value is 1 or 2, 1 means approve, 2 means reject, other means not voted

====getVotedAddress====

<pre>
fn get_voted_address(hash: &H256) -> Vec<VotedInfo> {}
</pre>

Users can invoke this method to query all voted address and vote result of a topic.
The parameter <code>hash</code> is the topic hash.

Return value is array of all the address and vote result.

====getTopicInfoListByAdmin====

<pre>
fn get_topic_info_list_by_addr(gov_node_addr: &Address) -> Vec<TopicInfo>{}
</pre>

Users can invoke this method to query all topicInfo of a admin.
The parameter <code>admin</code> is the topic creator.

Return value is array of topicInfo.


===Events===

====createTopic====

<pre>
CreateTopicEvent = RegisterAction("createTopic", "hash", "topic")
</pre>

The event must be triggered when topic are created.

====VoteTopicEvent====

<pre>
VoteTopicEvent = RegisterAction("voteTopic", "hash", "voter")
</pre>

The event must be triggered on any successful calls to <code>voteTopic</code>.

===Implementation===